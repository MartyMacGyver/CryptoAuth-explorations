// ----------------------------------------------------------------------------
//         ATMEL Microcontroller Software Support  -  Colorado Springs, CO -
// ----------------------------------------------------------------------------
// DISCLAIMER:  THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
// DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
// OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
// EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// ----------------------------------------------------------------------------
/** \file
 *  \brief  Application examples that Use the SHA204 Library
 *  \author Atmel Crypto Products
 *  \date   June 1, 2012
 *
 *   Header file for Anti-piracy example main.
*/
#ifndef SHA204_EXAMPLE_MAIN_H
#   define SHA204_EXAMPLE_MAIN_H

struct ChallengeSet {
	uint8_t Challenge[32];
	uint8_t Response[35];
	int      SlotNum;
	};
	
/*
Notes:
One would normally not want the slot used for a fixed challenge response to be writeable, not with
a clear write or with a derivekey command.  For the default chip configuration, that leaves only
slot zero as an appropriate target for the command.  However, if the chip is configured, as it normally would
be on manufacture, then many or all slots could be configured.
Cryptographically, this doesn't add a lot to the solution for fixed challenge response, but for other uses it
might.  For example, storing the response in a slot.
This code is structured so that it is simple to change slots, even though doing so is not really
advisable against a factory chip.
There are 10 here - a program could generate a thousand in a minute.
*/
struct ChallengeSet ChallengsetArray[11] = {
	// 0 checked out
	{"Here comes the client challenge.", {0x23, // count of Mac response packet: count(1) + MAC(32) + CRC(2)
		0x13, 0xE0, 0xCE, 0xA1, 0xA0, 0x12, 0xC6, 0x18, 0x73, 0x30, 0x5E, 0x6A, 0x68, 0xCA, 0x92, 0xD6,
		0x4E, 0x40, 0x81, 0x46, 0x29, 0x2B, 0x8B, 0x82, 0xFB, 0xC4, 0x1E, 0x2D, 0x0D, 0x54, 0x60, 0x36,
		0x0C, 0x89 }, 
		0x00},  // slot
	// 1 checked out
	{"Has to be exactly 32 characters.", {0x23, // count of Mac response packet: count(1) + MAC(32) + CRC(2)
		0xd9, 0x27, 0x52, 0x8f, 0x29, 0x0b, 0x10, 0x6c, 0x2a, 0x1d, 0x5b, 0x8f, 0x00, 0x93, 0xd7, 0xc7,
		0x75, 0x97, 0x5f, 0xf5, 0xc1, 0x28, 0x63, 0xe9, 0x75, 0xca, 0x78, 0x3f, 0x89, 0xa3, 0x11, 0xb9,
		0x36, 0xf9},
		0x00}, // slot		
		// 2 checked out
	{"Can just be a 32 byte random val", {0x23, // count of Mac response packet: count(1) + MAC(32) + CRC(2)
	    0x06, 0x63, 0x7f, 0x5a, 0x50, 0x89, 0x1f, 0x0f, 0x3a, 0xb1, 0xb5, 0xab, 0x1d, 0x4a, 0x8e, 0xe1, 
		0xd2, 0x56, 0xb2, 0x59, 0xd7, 0x75, 0x1a, 0x45, 0xb5, 0xe7, 0x89, 0x6e, 0xc9, 0xe3, 0xa8, 0xb1, 
		0xce, 0x7e},
		0x00},  // slot
		// 3 checked out
		// notice that this is the same as the above array entry, but in byte form		
	{{ 0x43, 0x61, 0x6E, 0x20, 0x6A, 0x75, 0x73, 0x74, 0x20, 0x62, 0x65, 0x20, 0x61, 0x20, 0x33, 0x32, 
	   0x20, 0x62, 0x79, 0x74, 0x65, 0x20, 0x72, 0x61, 0x6E, 0x64, 0x6F, 0x6D, 0x20, 0x76, 0x61, 0x6C},	   
	  {0x23, // count of Mac response packet: count(1) + MAC(32) + CRC(2)
	   0x06, 0x63, 0x7f, 0x5a, 0x50, 0x89, 0x1f, 0x0f, 0x3a, 0xb1, 0xb5, 0xab, 0x1d, 0x4a, 0x8e, 0xe1,
	   0xd2, 0x56, 0xb2, 0x59, 0xd7, 0x75, 0x1a, 0x45, 0xb5, 0xe7, 0x89, 0x6e, 0xc9, 0xe3, 0xa8, 0xb1,
	   0xce, 0x7e },
	   0x00},  // slot	
	   // 4 checked out 	     
	{"AzpT3_LzyD45..&Smzy8@3 ijndser%)", {0x23, // count of Mac response packet: count(1) + MAC(32) + CRC(2)
		0x3f, 0xab, 0xd1, 0x8c, 0xfa, 0xc8, 0xe7, 0x4a, 0x9b, 0x15, 0x6c, 0xe3, 0x1f, 0x30, 0x6f, 0xe2, 
		0xa3, 0x8e, 0x77, 0x97, 0x96, 0xc9, 0xc9, 0xf6, 0x20, 0x10, 0xc1, 0x93, 0x1a, 0x2a, 0x45, 0xd3, 
		0x71, 0x2f },
		0x00}, // slot		
	 // Guessing the output of a SHA204 is very unlikely.  Guessing the input, not so much.	
	 // 5 checked out
	{"ASCII is easy but not as random.", {0x23, // count of Mac response packet: count(1) + MAC(32) + CRC(2)
		0xeb, 0xbe, 0xcf, 0x7d, 0x07, 0x3f, 0xf4, 0xae, 0x1c, 0x99, 0x89, 0x83, 0x83, 0x5a, 0x8d, 0x84,
		0xe8, 0x78, 0xe7, 0x94, 0xf0, 0x72, 0x90, 0xf4, 0x56, 0x2b, 0x7e, 0xfd, 0x9e, 0xc5, 0x85, 0x82,
		0x59, 0xe3 },
		0x00}, // slot
	// 6 checked out
	{"One of these will be picked by a", {0x23, // count of Mac response packet: count(1) + MAC(32) + CRC(2)
		0xb7, 0x69, 0x18, 0x53, 0x8c, 0xec, 0x40, 0xba, 0xe1, 0x4c, 0xbc, 0xd2, 0x35, 0x6c, 0xdc, 0x63,
		0x56, 0x80, 0xc7, 0x75, 0x91, 0xab, 0x13, 0x8c, 0x93, 0x6a, 0x51, 0x1d, 0xac, 0x3c, 0x52, 0xeb,
		0xec, 0xa9 },
		0x00}, // slot		
	// 7 checked out	 
	{"random function.  Which is not a", {0x23, // count of Mac response packet: count(1) + MAC(32) + CRC(2)
	   0xe8, 0x46, 0x83, 0x19, 0x06, 0x19, 0xb2, 0xb7, 0x8d, 0xa7, 0x31, 0xf5, 0x24, 0xc2, 0x63, 0x73,
	   0x27, 0x2f, 0xa2, 0x7b, 0x60, 0x19, 0x7e, 0xa0, 0x97, 0xde, 0x26, 0xd0, 0xde, 0xfc, 0x72, 0xa9,
	   0xcf, 0x3e },
		0x00}, // slot		
	// 8 checked out	
	{"big concern as long as it is un-", {0x23, // count of Mac response packet: count(1) + MAC(32) + CRC(2)
		0xf3, 0x65, 0x82, 0xd3, 0x11, 0x0c, 0xb9, 0x53, 0x49, 0x36, 0xd8, 0x96, 0xaa, 0x3e, 0x90, 0x0d,
		0x2c, 0x50, 0x18, 0x09, 0x34, 0xf5, 0x09, 0xa7, 0x09, 0xcb, 0x47, 0xe9, 0x61, 0xaf, 0xf0, 0x71,
		0x84, 0x6c },
		0x00}, // slot		
	// 9 checked out
	{"predictable. Someone must try 32", {0x23, // count of Mac response packet: count(1) + MAC(32) + CRC(2)
		0x4e, 0x2a, 0x08, 0x53, 0x33, 0xb6, 0xf2, 0xba, 0xf0, 0xcd, 0xec, 0xdd, 0xe2, 0x0d, 0x18, 0x34,
		0xe8, 0xec, 0x6b, 0x2b, 0xfa, 0x9b, 0x23, 0xc4, 0x63, 0xc2, 0xbb, 0x8c, 0x07, 0xe3, 0xb4, 0x47,
		0x3c, 0xb5 },
		0x00}, // slot		
	// 10	 
	{"byte strings, or 2 ^ 256 values.", {0x23, // count of Mac response packet: count(1) + MAC(32) + CRC(2)
		0xeb, 0xbe, 0xcf, 0x7d, 0x07, 0x3f, 0xf4, 0xae, 0x1c, 0x99, 0x89, 0x83, 0x83, 0x5a, 0x8d, 0x84,
		0xe8, 0x78, 0xe7, 0x94, 0xf0, 0x72, 0x90, 0xf4, 0x56, 0x2b, 0x7e, 0xfd, 0x9e, 0xc5, 0x85, 0x82,
		0x59, 0xe3 },
		0x00}, // slot					
};  // end struct array


#endif